[ { "title": "A Product Perspective for Software Hackers", "url": "/posts/product_perspective/", "categories": "Tech, Career", "tags": "tech, career", "date": "2020-10-25 00:00:00 +0530", "snippet": "Caring deeply for, and being in love with our code is something that comes naturally to all of us who treat coding as our craft.It is a natural approach for artisans to think deeply, code meticulou...", "content": "Caring deeply for, and being in love with our code is something that comes naturally to all of us who treat coding as our craft.It is a natural approach for artisans to think deeply, code meticulously, and then forever and always guard our creation with the passion of a zealot.This almost always works beautifully for small, well defined (or well definable) modules of code.When I became a Lead1, it was natural for me to carry the same approach towards building larger systems.Given a problem statement, I worked to find a grand design. It was always built to scale. With a model so good, it would last a lifetime of changes.I firmly believed that, once it was conceived, all future tradeoffs were in deference to this grand design.Any requirement and/or change that was a deviation from this was a hack or tech-debt. Too many changes meant we were losing our way and must defer to our design deity for future course correction.There were early warning signs that this was not the best way to approach things.I distinctly remember a conversation with the Head of Engineering who had a different approach to building systems.To him, it was all about the product, not the system. The architecture/design, so to speak, was simply a set of reasonably well thought out boxes - something that one can come up with an hour or two of pondering - not unlike what we expect to get from good2 system design interviews.The initial set of boxes are enough for us to get something out there and start our learning process. There is nothing permanent about this architecture - it simply keeps evolving along with the product.I didn’t dwell on the fact that he mentioned product multiple times, didn’t really mention the word system.Years later, the grand design driven development approach (and, my developer pride) came under more direct attack.I was part of the infrastructure team and we needed to make some core changes. I proposed a grand design whereas a coworker proposed a quicker solution that seemed suboptimal to the purist in me.My argument: This is a core infrastructure piece and lets take time to build it right.His argument: Building it right will take weeks whereas his proposal would lead to immediate productivity benefits for engineers that would lead to more features for our customers which means more dollars for the company now.Dollars?, Sales?, Customers?. Doesn’t my company have an unlimited supply of those?Besides, weren’t systems supposed to be built right ? Shouldn’t it always scale from now to forever? Didn’t getting it right trump getting it early?Well, turns out - almost never.My coworker was right. I was missing the bigger picture - of what mattered to my company and how, what I was working on fit into the larger product picture.It was important for the company to save man hours now to make a better product faster.Look, I’m not saying there is no place for good engineering. But engineering is all about tradeoffs, right?These have to be a function of what the company / product needs and not your affinity to a great tech solution.These tradeoffs can almost always be mapped to the real MVP - the customer.And, when it comes to $$, customers or productivity benefits - it’s almost always more important to have them now than some time from now.Few people are capable of managing these tradeoffs efficiently while delighting the customer. I wish there was a handbook I could cite here, but there isn’t.It is imperative, I think, for a software developer to develop an intuition towards knowing what’s best for the customer.You may think it doesn’t apply to you. You may be working with a brilliant Product Manager, or may be part of a core engineering team far removed from the end product.I disagree. For one, you may not be in that position forever. Two, some of the most kickass engineers I know worked on core infrastructure in Azure. Not only was their knowledge about their system unparalleled, they went above and beyond themselves to work closely with us, understand our needs and ultimately use those inputs to build their product better.So how does one build intuition around what’s best for the customer? Well, I’m still learning too! But here are a few things that have helped me Be your own customer. Also known as dogfooding Go talk to your customers!If you’re developing a consumer product, find someone that uses it and talk to them about what they love or hate about it!If you’re into enterprise SaaS, get on a sales call or go out in the field with someone from Sales3 Work with DesignersDesigners, the really good ones I’ve been fortunate to work with, have this amazing ability to step into the shoes of their customers.An ability to think like a designer - to visualise the final solution for your end customer - is a life skill for a developer! At the very least, Bug your Product ManagerLike most of you, I love to fight with the PM. Sometimes it’s just so fulfilling to say No and win.But it’s also important to understand their thought process. Probe them. Empathise. Keep doing this till you can truly understand their mental model - especially how/why they prioritise what to build.Remember, even the most sophisticated technology is useless if it doesn’t empower, improve the life of, or bring joy to the customer.Would love to read about your experiences building products &amp; systems! Please feel free to email or get in touch over LinkedIn Thanks to Sourav for helping me write this and providing feedback.FootnotesPS: The title of this is somewhat inspired by A Hardware View for Software Hackers . An old piece, but a must read if you haven’t already. Which was very early in my career, thanks to being in a high growth startup &#8617;&#xfe0e; These are not the ones where we have to design Uber in less than 30 mins &#8617;&#xfe0e; Btw, they’ll always have great stories to tell! &#8617;&#xfe0e; " }, { "title": "Build a dev career for the long haul", "url": "/posts/dev_career_for_the_long_haul/", "categories": "Tech, Career", "tags": "tech, career", "date": "2020-08-01 00:00:00 +0530", "snippet": "I’d like to believe I’m not old enough to hand out career advice with authority.1Although, occassionaly, I am on the receiving end of innocently hurtful comments from fresh grads who say, “Oh, I di...", "content": "I’d like to believe I’m not old enough to hand out career advice with authority.1Although, occassionaly, I am on the receiving end of innocently hurtful comments from fresh grads who say, “Oh, I didn’t realise you’re more than 10 years older than me”2.I consider myself fortunate to have been around some amazing mentors.At the very least, I hope this turns out to be a distillation of advice I’ve received over the years from people smarter than I am.It’s a longish read, but if you are in a hurry here’s the most important advice:Hunt for a great mentor and just latch on to them. If you can’t find one, then hunt for one outside of your current workplace/environment.The surest way to upskill yourself is to be taught by someone who is very good at what they do.[Choice of] Place of WorkA wise person once said, “A good place to work is one where the feeling of loserishness is prevelant”.Simply put, you’re at the right place if you feel like a loser next to the folks around you.The around you part is important. Admiring accomplished coworkers from far off won’t help you level up.If possible, try to be part of a team with someone you look up to.A large part of your learning will come from your immediate peers. Surround yourself with folks who are more accomplished, more hungry and more driven than you are - you’ll feel like a loser in front of them, but you’ll learn the most too.I know, working closely with someone you look up to can be intimidating.But apart from ridiculously fast paced learning, there is a great side effect to it too. When you carefuly observe people, you realise that everyone is human and has their own shortcomings.This makes it less intimidating over time and encourages you to build a thought process that is inspired by, but hopefully free from, your mentor’s biases.Stick to ProjectsSubstantive learning comes from feedback. As a developer, you’ll get feedback from all quarters - peers, managers, team leads &amp; perhaps even customers.Your code gives you feedback too. The code you write &amp; the product it brings to life are constantly evolving.That abstraction you crafted will become too brittle in a few months.That API you so agonized over will no longer be used.If you’re lucky - you’ll get to see your code undero major refactoring or even a rewrite!It is imperative that you stick around to witness this. Only through multiple iterations does one develop an intuition about what really matters when you code.In my last company, we had taken the decision of not using any ORM.3When a new recruit asked why, I simply said that it’s because all ORMs suck.He was semi-offended at that. He mentioned he’d used &lt;foo-ORM&gt; in a dozen or so services in the past without encountering any issues.I tried to explain how as the code ages &amp; the data model gets complex, you end up having to manage the ORM more than manage your own code.Since we’re a startup, our data models would see constant flux for the foreseeable future. Hence, it was much easier to pick vanila SQL than to wrangle with an ORMWhat I said didn’t appeal to him very much and was evidently not convinced with our collective reasoning.I gave him various scenarios where simple things like multi table queries, frequent migrations with backward compatibility etc with &lt;foo-ORM&gt; would become a hassle.Some of these seemed to bring him round a bit, but he mentioned he still liked the convenience &lt;foo-ORM&gt; offered.On further introspection, we realised that the convenience is merely that of a few saved SQL queries.During our conversation, I also found out that in his previous company, he had not been able to stick around a project for more than a quarter or two.Thus, while he had used &lt;foo-ORM&gt; during the initial setup, he had never been in a position to have felt the pain I spoke of.If he had had the opportunity to stick around long enough, he would have learnt a bit about the trade-offs that come with it.Iteration brings this wisdom. When you’re face to face with your past choices, you innately learn about how valuable they really were.Of course, there is no one universal truth - your experiences will shape how you think as an engineer.Perhaps requirements will change too often and you’ll end up hating PMs.Perhaps you’ll hit scale sooner than expected and start taking observability &amp; infrastructure choices more seriously.But at at a bare minimum, you’ll learn about at least one thing that matters in the long run and about a dozen other things that really don’t.Take up a Shitty Maintenance ProjectNow, I know you think I’ve gone completely bonkers!But, trust me, that is not career suicide!The very first project that I took up as a ‘Lead Engineer’ was a bug infested, Oh-Lord-How-Does-This-Even-Work, Step-Child-Of-7-People nightmare of a project.To make my nights more fun and interesting, it was suddenly designated as a core platform project. The multi billion dollar company I worked for wanted to rely on it to provide critical alert functionality for their biggest upcoming October Sale.\\There’s a saying, “Always code as if the person who ends up maintaining it is a violent psychopath”. Obviously, people who wrote this junk hadn’t heard it.I was the psychopath, but I couldn’t turn violent because I didn’t have time for that!Since violence wasn’t an option, my subconscious mind chose to reconcile itself through literal nightmares instead.Despite the pressure, I can safely say that I learnt a ton from other people’s mistakes (and without the blame/guilt that comes with making them!)Moreover, it helped me with some valuable skills The ability to read code and make sense of it! The confidence of being able to take up any code base (as shitty as can be) and be able to mould it as my own4.Both are something I pride myself on, and have come in extremely handy over the years.Be PatientDuring one particular evaluation cycle, I really thought I deserved a promotion but I didn’t end up getting one.Coincidentally, I was also changing teams at the same time. So my performance discussion happened with my to-be manager in the same room along with my ex manager.I explained how I had clearly outperformed compared to what was expected, deserved the promotion and was being treated unfairly. I was outright rude.Rather than being alarmed by such hostile behaviour, my new boss uttered the single most profound advice I’ve received - “So?”The fuck did he mean by that?5“Did you get to work on interesting stuff this past year?”. Yes“Do you think you gave it your best and are a better engineer today than you were a year before?”. Yes“Do you care about the little bit extra money you’d get if you were promoted?”. No“So how does it matter? Just suck it up and do what you’ve been doing”. Profound.And of course it didn’t matter! What matters more is that it’s been 5 years to the day and he’s still someone I go to whenever I need some honest, no bulshit advice.6I know - perhaps you’re skeptical. Thinking it doesn’t apply to you since you’re in a competitive, politicaly charged environment and these things matter.No they don’t. Trust me, I’ve been there. The above advice snapped me out of it and made me realise that how much you improve each day/week/month/year at the craft you care about &amp; the relationships you build over time are what matters.One missed promotion, one missed opportunity doesn’t matter. If you’re hungry - you’d get round to the next one.Footnotes People are always remarking how young I look. Surely they can’t all be flattering me. Hopefully. Maybe. &#8617;&#xfe0e; Sunny, it’s been 2 years but it still hurts :) &#8617;&#xfe0e; This was taken before I joined - and boy was I glad! &#8617;&#xfe0e; I have a blueprint now. Something I can write about some other time &#8617;&#xfe0e; Well, I didn’t use those exact same words - it was too early to show my true colors :) &#8617;&#xfe0e; I’m sure he doesn’t remember this one bit. He’s too busy being high on life. &#8617;&#xfe0e; " }, { "title": "Tales of Tech Interviews", "url": "/posts/tales_of_tech_interviews/", "categories": "", "tags": "", "date": "2020-05-29 00:00:00 +0530", "snippet": " My First Interview Interviews with BigTechs Product Centric Interviews Best Interview Ever Parting ThoughtsI like to believe that I’m a decent developer. There’s no real proof of that, apart ...", "content": " My First Interview Interviews with BigTechs Product Centric Interviews Best Interview Ever Parting ThoughtsI like to believe that I’m a decent developer. There’s no real proof of that, apart from the bits n pieces occasional compliments from coworkers; and theabsence of outright remarks of evident stupidity over the last ~8 years.I’ve always loved programming, and - at the same time - I’ve always sucked at competitive programming.Basically, if there was a gun to my head and the only way I could get out of it was by solving a programming puzzle, I’d start making calls to the people I love.That should serve as a decent precursor for the tales to come, and how I generally fare in tech interviews.My First InterviewThis was for a BigTech company in college. I was the crowd favourite to get through1.The interview started. I was completely bamboozled by the question. I knew I basically had to narrow down to a data structure, but for the life of me I couldn’t settle on one!Needless to say, the 2nd question never came.After the interview, a friend was kind enough to point out that it was a ‘simple tournament tree’ problem. Tournament what now?To me, in the interview room, it was equivalent to being asked to figure out the equation for the quantum wave function in 30 minutes.Over the next 15 days, before my next interview, I inhaled the contents of Cracking The Coding Interview .I guess it was only because of CTCI that I feel I interviewed reasonably well. That, and the fact that my interviewers asked some offbeat questions andvalued first principles.Interviews with BigTechsOver the course of my work life, I’ve interviewed with other BigTech companies only twice - and with predictable results.Here’s how one phone screen went:Interviewer: Hey, I'm &lt;name-I-can't-recollect&gt;Me: Hey there, how's it going?Interviewer: Going good. Here's your questionGiven a number 'n', Print brackets in a certain wayIt took me about 30seconds to realise that I’m not gonna get this one.Don’t get me wrong, I am not a pessimist or a giver upper - I just know what I don’t know.Still, I tried to solve the puzzle - thinking out loud all the time2, which was met by radio silence from the other end.About 10 minutes in, the interviewer also realised that this wasn’t going anywhere - but we were both duty &amp; honor bound to see it through for the next 30 minutes.Such a waste of valuable human time. I almost wanted to apologise.Days later it was pointed out to me that this was a ‘simple DP problem’.A similar episode came up with another BigTech. I was asked a variation of Binary SearchThe expectation, of course, was to get the solution quickly and then code it out (on paper)3 while covering all the tricky edge cases.If you’re following the trend here, that - of course - didn’t happen. I took like 5 minutes4 to get those bounds right; but of course, the interviewer gleefully pointed out all those edge cases one by one. I think this time I did end up apologising.This is not meant to evoke any sympathy towards my inability to interview well. I’ve been blessed to have a rewarding career so far and worked with some of the best people around - all outside of BigTechs.This is also not about the grapes being sour - it is not a critique about the process that BigTech companies followHowever, it’s notable to point out that I don’t remember even the names of my interviewers, let alone remembering what they did or about their teams.I did not have a very engaging conversation with them as they got right to the question.These are the learnings that I try to incorporate as an interviewer. Most people forget that an interview is a conversation first.At the very least, we can try to make it a good, engaging conversation. I always start my interviews trying to have a decent conversation with interviewees rather than ‘getting down to business’.A good side effect of this is that it generally helps the candidate relax.Sure, they may not meet your standards in the end, but it is still worth spending some time engaging them.At the very least, they’ll have a decent time and you would have done well as an ambassador for your company.At best, they would remember that and write about you in a blog a few years down the line5.Product Centric InterviewsMy interview with booking.com was my first experience of a process which was tailor made to reflect company culture and priorities.The first phone screen was taken by a software developer and an employee from the customer experience team. It was a refreshing revelation!6. The pre-question and post-question conversation was especially enriching since I got to know more about the company and not just the tech team.Similarly, in one of their on-site rounds, I was asked a question that circled around a hotel owner’s working capital. This had nothing to do with data structures or algorithms and was the first time I actually thought of a real customer problem during an interview.I don’t think I did well there and I didn’t get the offer. But I still remember most of the conversation and the name of my interviewer.7The biggest takeaway from booking.com interview, as was pointed out by my interviewer, was “Basically we are here to solve a business problem. It’s important to us to evaluate how people approach such problems”. They didn’t pretend to be a hardcore tech company and were sincere and straightforward about what they were looking for. Despite not getting the offer, I loved the experience.One of the companies I later ended up working for had a similar interview process and I whole heartedly subscribed to it.If we are not inventing new algorithms day to day or even once in a while then it’s important not to focus on those aspects of programming, and instead focus on what we will end up doing day to day - which is solving a problem related to the company’s business.Luckily, I see a lot of companies coming around to this idea.There may be a lot of you reading this who may not align with this - which is fine. But I do suggest at least trying out with a company with a different hiring process - you may be enriched by the experience alone.Best Interview Ever8My best interview experience, in fact, wasn’t even an interview at all. It was the initial email exchange I had while interviewing for DataStax.DataStax is all remote, and I loved how their recruiting process was tailor-made for their needs.The first email had a set of 3 questions What do you know about data structure X and Y. When would you prefer X and when would you use Y Develop an algorithm to solve a problem (which was evidently applicable to a distributed database) Think about various optimisations to the above solution under different constraintsI was blown away by the simplicity yet effectiveness of this first screening round.It checked my technical skills, the stuff I kept in mind while thinking of real world implementation &amp;&amp; the way I presented my thoughts.Even though I was really impressed by the screening email itself, I was further blown away by the next task.I was asked to download Cassandra and implement a certain feature in it. If I needed help, I was pointed to the IRC and mailing list. That’s it!9What an incredible way to screen for exactly what you value - right from the get go (and before any 1-on-1 interviews).We had to cut the process short since I had an offer from another company - I didn’t want to waste my interviewer’s time, even though I would have loved to go ahead with the process.Parting ThoughtsTo me, Hiring is one of the most important processes for an organisation, yet it is often overlooked.It basically determines who comes in and sits next to you to share the day to day burden of your challenging work.It is specifically crucial for startups to ensure that the process tests for the skills that are relevant for day-to-day jobs, rather than aping established processes by bigger companies.Another part that generally gets missed out is iteration &amp; reflection. Once a hiring process is set, it almost never gets changed.A/B deployments and iteration techniques are a given when it comes to building a product these days, I wonder why it is not applied to internal processes too.Also, a quick word for younger devs out there:Try not to make it your life’s mission to get to a specific company.There is little to no correlation between how great a career you’ll build with the company you work at.Being in a BigTech won’t guarantee you’re surrounded by geniuses; and being at a startup doesn’t guarantee that you’ll morph into a rockstar or an urban legend.If you’re really looking to build a solid and fulfilling career, try to focus on yourself and improving your skills.Lastly, don’t get disheartened if a few interviews go bad. Unfortunately, no matter how much we try, interviews cannot be 100% objective. So a few of them going bad don’t mean much.If a lot of them are going bad, that’s ok too - look for a company with an interview process that is different (not easier) than the ones you’re trying out for. You may just chance upon a great fit!Would love to read about your interview tales too! Please feel free to email or get in touch over LinkedIn Thanks to Ravi, Sourav &amp; Suman for helping me write this and providing feedback.Footnotes: Top 3 in class; teacher’s pet; geek etc etc &#8617;&#xfe0e; That’s the advice you get at all interview websites &#8617;&#xfe0e; I never understand why we’re made to code on paper &#8617;&#xfe0e; Oh, the Horror! &#8617;&#xfe0e; See what I did there? :smirks: &#8617;&#xfe0e; I don’t know if they still do that or not, I interviewed with them half a decade ago I think &#8617;&#xfe0e; Fun Fact: At a later stage in life, I ended up working in payments where working capital - of my company as well as our vendors - was the core problem to solve for :) &#8617;&#xfe0e; Excuse the hyperbole. &#8617;&#xfe0e; Of course, I was given the fallback to call upon the interviewer if I was stuck. They’re not monsters! &#8617;&#xfe0e; " }, { "title": "Time is the only real currency we have", "url": "/posts/time_is_the_real_currency/", "categories": "Tech, Productivity", "tags": "tech, productivity", "date": "2020-04-16 00:00:00 +0530", "snippet": " A Note on ‘Software Engineering Stuff’ Stressed And Struggling For Time Things That Matter (Time Savers) Learn to type Fast TurboCharge your Dev Environment Automate Kno...", "content": " A Note on ‘Software Engineering Stuff’ Stressed And Struggling For Time Things That Matter (Time Savers) Learn to type Fast TurboCharge your Dev Environment Automate Know your infrastructure Things That Don’t Matter (Time Sinks) My Language is the best (Or, your language sucks) ‘X’ doesn’t scale, Lets Switch to ‘Y’ Lets use a &lt;thing-i-just-learnt-about&gt;. Its perfect for the job Your way is wrong “Well, that’s the thing right - Time is the only real currency we have”. This was the singularly brilliant summation of a long discussion the company’s founder and I had. It was one of those long walks we occasionally took in the middle of the afternoon - when the weather was still pleasant and there was a lot to talk about. The topic of discussion was Developer Productivity. We were 1 the fastest growing company in India and had hit a Billion Dollars in valuation with a team of about 20 engineers. Developer productivity wasn’t just an aspirational goal for us. We needed to be highly productive to even survive the challenges we faced on a daily basis and what lied ahead of us. I’ve always heard Time == Money, but that never really struck me as vividly as the above statement. I feel it is profound and cuts through all clutter in our head.Now that I have some more time to reflect on it, I wanted to try and best summarise what I’ve learnt on my journey so far. This is a result of ~8 years of introspection &amp; observations while working in some of the fastest growing companies on the planet . Hopefully you’ll take away something that helps you in daily time management.A Note on ‘Software Engineering Stuff’Before we start off, I want to quickly put out a short disclaimer (I consider this important enough to give it it’s own subsection)All ‘Engineering Stuff’ - from the way we write code, to design choices, to the tools we use come with tradeoffs. This is the only universal law of software development (if there ever was one).There is no ‘absolute right’. If there were, you and I wouldn’t be needed much.That applies for this post as well, so don’t come charging towards me with a flame thrower.But while we don’t have an ‘absolute right’, we are lucky enough to be in a field where logical conversations are generally possible and a question of whether it is raining or not can usually be settled by stepping outside.2Stressed And Struggling For TimeOff late, when I got talking to a whole bunch of software developers around me, the theme of burn out and never-having-enough-time was surprisingly recurrent (Surprising because, it was the exact same thing I go through as well - I thought I was a special snowflake with the weight of the world boring down upon me. Alas)When I reflect on it, it seems quite odd.Think about it - programming these days should be easier. We are a product of decades worth of research and innovation in the field of computer science and softwareengineering - but most of us work way too hard (or, at least seem to work way too hard) , spend more time than necessary in dealing with bugs and are almost always behind deadlines.Most of us are working on a significantly higher plane of abstraction - on languages such as Python, Kotlin, Go etc.We almost never have to worry about memory management (unless you are one of the 8 people on the planet working on improving the garbage collector implementation)The frameworks of today help us in invariably pointing the gun in the right direction, but we never seem to ‘nail the target’ once and be done with it.We are always behind our product schedule and we want things to end - but they never do.My observation, here, is that we end up spending way too much time on things that don’t matter and spending increasingly lesser time on things that do.Things That Matter (Time Savers)Learn to type Fast‘But software engineers spend more time thinking than typing’, I can almost sense you thinking. Agreed.However, whenever you do choose to grace the keyboard, your fingers must be in a position to do your bidding almost as fast as your brain thinks.Typing fast is one way to easily get one of the most mundane parts about our jobs become less painful.You don’t want to be the person who thinks their problem through on a piece of paper, has all the ‘structure ready in the head’ but gets bored halfway through implementing it since it’s a lot to type out and it’s taking a lot of time.More importantly, learning to type fast will help you interact with your developer environment a lot more efficiently.If you’re a Jedi, then think of the keyboard as your light saber. Be one with it and you’ll slice through anything that comes in your way.How to do it? Don’t go out looking for the best keyboard on the market. Just download GnuTypist and do the touch typing course. You’ll find your basic laptop keyboard (butterfly keys or not) is capable of rocket speed with the right training.TurboCharge your Dev EnvironmentIf you imagine you’re a Jedi3, then your dev environment is the force. You can use it to move mountains by just focussing your energies and leveraging it’s powers.Baby Yoda The Force GIF from Babyyoda GIFsMaster your IDEI have interacted with many engineers who treat their IDEs as little more than a notepad - using it simply for code navigation, certain auto complete features and use some debugging features.But modern IDEs have so much more to offer.Want to rename a method? Change it’s parameters? Add Default values to parameters? All this can be accomplished via a single shortcut.Want to Toggle Breakpoints? Jump in and out of methods while debugging? Yup, can be done in a single stroke.How to do it?Every time you are presented with a task that requires you to do any of the following, spend 5 minutes to check if your IDE has a command for it Repeat a change multiple times (like renaming a method everywhere it is being used) Switch tabs or windows to get from one place in code to the other (like going back to the method that you edited 10 minutes back) Interact with an external tool (say, running your build by switching to the terminal) Whenever you are using the mouse - your IDE will have a keyboard shortcut for itAlso, spend 10 minutes a day going through any available tutorial for your IDE. In a month’s time you would have put in a solid 5 hours in learning a tool you use more than 1000 hours a year4.Master a terminal based text editorIn the age of IDEs, one should not forget the power of the text editor. While most of your coding would happen on an IDE, you’d invariably end up using a terminal based text editor for some part of your work.It may be while checking log files, or while writing a blog post (like this one) or logging on to a server and direct-editing files there5.I cannot imagine writing this blog on any other tool apart from my trusted vim. I have markers everywhere (adding a footnote is a keystroke away, for example), move lines from one section to the next in a blink and use the powerful search features to get around easily.Besides, learning Vim helped me improve how I work on my IDE (Vim Emulation FTW!)Yup, I use vim. You may use emacs. Here, go look at this, calm your nerves and come back.There’s a tool for everythingAs I mentioned earlier, we are blessed to be at a time and place where we can leverage ideas and hard work of thousands of people who’ve worked before us.Keep an eye out for things that bother you, think of a probable solution to the problem and chances are that there is already a tool to help you with that.If you don’t find one, email me and I’ll be happy to help you look for one. Using the mouse to copy-paste text from your terminal ? Use Tmux Learning something new and tired of switching back-and-forth between browser and IDE? Use i3 Ever wished you could navigate the browser with the keyboard? Use VimiumAutomate Here’s an old xkcd post suggesting the RoI of making routine tasks more efficient.But here’s the kicker - since we mostly work in teams, any effort put in by one person to automate routine tasks saves time for everyone.Going by the above calculation, if one person on a team of 10 engineers spends 3 whole days shaving off even 30 seconds on a task done by everyone only 5 times a day, we would have gotten a complete return on investment over a period of just 6 months. Bring that up in your next sprint planning meet.People always talk about the prodigious 5X engineer. The reality, though, is a lot more boring than that. 5X engineers, in my opinion, are those that help 5 more developers save some time in daily tasks.Just like other things, chances are that whatever you’re looking to do, there’s a tool for that. In case you’re having trouble finding one, email me and we can find one together.TestsTests are, unfortunately, one of those contentious ‘Engineering’ topics that I mentioned earlier.Each time you’ve written a piece of code, or reviewed a piece of code, or have spent time diagnosing a bug - if you have a test case for that method/class/API, you’ll be able to move faster (and this applies to all members for your team, mind you)I am personally whole heartedly subscribed to having tests at all possible levels one can, but that’s the thing - you don’t need to be. The quest here is to save time, and like with all ‘Engineering Stuff’, there are tradeoffs and there are more than one ways to achieve the same goal.Continuous Delivery Continuous Delivery processes help you significantly save time avoiding routine dances before a release.A word of caution, though - simply deploying to production multiple times a day does not qualify as continuous delivery.There is more than enough information on the principles and practices of CD on the website (and Jez &amp; Fowler’s books/lectures) that I need not go deeper into it.Just remember - the Returns of even 1 engineer’s efforts on setting up good CD practices are multiplicative.Script it outThe power of scripting for low-fi tasks is invaluable. Do you routinely check for the same ‘x’ things while diagnosing an issue? Script it out Is your company having a lot of new people joining the team and you have to explain the same steps to them, despite there being a documentation for it? Script it out Know your infrastructureWhen I was working as an infrastructure engineer, we routinely had emergency emails asking us to check if the infra is fine. Of course, it was always an emergency since the application was acting up and users were affected; and Of course, it must be the infra which is responsible for it.It’s easy to suggest,“It must be the kernel [or the network or the database or the infrastructure]”. Don’t be that person. Don’t guess things - learn to diagnose things on your own.Yes, we deal with complex systems when we deploy our code today. The application code we deploy may end up running in a container which itself is running on a Host Operating System running other containers; the Host OS may itself run as a Virtual Machine which may run on another completely different Operating System sitting in a big box which hosts 10s of such machines. Our code may ‘hit an API’ which results in multiple network hops - perhaps to a machine located in an adjacent building in the same ‘Data Center’.Every parameter of everything involved in that setup - from the configuration of the OS, to the number of applications running on the host system, to a link flapping on a network cable on the core switch can result in your application behaving weird. This is the reality. While it is almost impossible to know everything about your infrastructure, simple tools will help you navigate a large subset of routinely faced issues.Learn how things are deployed to productionFigure how/where your application code runs.Is it running in a container? What is the configuration of the host machine? Do you know where to look to get basic stats on CPU and IO usage (Network &amp; Disk)?Does traffic come to it via a load balancer? Where do you find the stats for that?How is a service call to a dependency (datastore or other application) made? Does it involve a network? If yes, how is that traffic routed?Knowing this would help you isolate issues faster. This will help you apply The Box technique to isolate performance bottlenecks.Learn more about your datastoreInvariably, a significant part of your application’s job would be either reading from or writing to a myriad of data stores.Basically, If you’re married to your application and love it, then the datastore is like extended family. You must spend time learning more about it.A colleague once brought a replication lag of ~3hours down to under 1second on a MySQL slave by simply RTFM on various configurations of the storage engine.Similarly, I’ve seen a DBA mitigate a crisis (of what everyone thought was a DDOS) by zeroing in on a query and running EXPLAIN for it.These may seem like wizardry, but it is mostly just people RTFM and spending time to learn more about the datastore their application adores.Things That Don’t Matter (Time Sinks)My Language is the best (Or, your language sucks)I once attended a conference where the founder of a hot-startup proclaimed, on stage, that they chose ‘Functional Programming’ over procedural because it is ‘Theoretically Superior’.No, it is not. Both Church and Turing proved that.More importantly, any functional code you write is converted to it’s Turing equivalent - we don’t have a real machine built on church calculus.Such ideological stances are generally rooted in half baked understanding of things and compounded by the desire of someone to come off as cool by knowing more about esoteric/obscure or even the latest-and-greatest-shiny-new-thing.Sure, [Modern] functional languages are designed to help provide less ways to shoot oneself in the foot , but a well oiled C++ company6 would have evolved standards and patterns to write as beautiful a code than what a company working on Kotlin or Scala can; so where’s the difference?It’s all about finding what works best for you, taking early bets and seeing them through.booking.com used to work on perl; cleartrip.com on lisp; udaan.com works on kotlin ; there are 1000s of successful companies working in Java/C++. It doesn’t matter.What matters is how productive the organisation is - how effective developers are at making progress on the job at hand - and whether or not it is helping you move forward.‘X’ doesn’t scale, Lets Switch to ‘Y’During an interview with a young dev, I enquired as to how he had ‘helped scale up &lt;service x&gt; and made it more performant’. He revealed how his mentor had advised him to switch to python web server because nginx is slow. It is indescribable7 how I felt when I heard this. But after a few brief seconds of an emotional whirlwind, I empathised with him.In a similar vein, in another interview, someone described how they ‘moved away from JSON to GRPC’ because JSON was bloating their APIs too much and GRPC is more performant.I do not want to get into the merits/demerits of the choices they took (thereby, abiding with the advise that I am repeatedly giving here).I do, however, want to draw your attention to some facts that apply to most of us in general:We live in a time where we can easily procure and deploy very powerful hardware. Unless you have chosen some of the worst written frameworks8, they will ‘scale’ more than you may imagine .The word scale is also one of those things we notoriously are prone to brag about based on our half baked understanding of things and the desire to be ‘cool’.I used to be one of those people. Back in the day, we were proudly managing a service with 10k reads-per-second (has your jaw dropped yet?) backed by a 32core 128GB MySql machine.I was proud of the ‘scale’ we had managed to weather, until a dev with about 15 years of experience joined our team. He casually remarked one day that he could run 3 of his last startups with that much computing power9.I learnt a big lesson that day, that life is not a bragging contest. Also, what we think is scale is probably not. We are prone to boast of our accomplishments but they are largely the result of us standing on the shoulders of giants.While dealing with and handling scale is beyond the scope of this blog post, I’d leave you with this general advise Learn one base tool for the job and learn it really really wellFor e.g, pick up nginx/apache web server and I almost guarantee you that these will break much much later than your entire application stack. RTFM &amp; BenchmarkBenchmark every tool/technology that you are picking up. This way, you’d be more aware of the ‘limits’ of that technology.How you benchmark is beyond the scope of this post (perhaps even beyond the scope of me) but a simple process can yield fairly good results.Push a technology to its limits by maxing out the resources (compute / memory / network / disk IO) it is supposed to consume on a common piece of hardware (which you’ll most likely employ in production)Once you max it out, RTFM and tweak it to ‘improve’ upon the limit that you just hit.Repeat till you’ve either satisfied your intellectual curiosity, or realised that the solution you’ve chosen can handle 10x more of your predicted scale.Lets use a &lt;thing-i-just-learnt-about&gt;. Its perfect for the jobA young dev we hired was given the task of writing a simple CRUD application. The Update part of it, I thought, was particularly tricky, so I figured it’d be a project right up his alley and challenge his skills. He was sharp, full of energy &amp; wanted to prove himself - everything you want in a young developer.He also wanted to use a &lt;distributed-highly-scalable-queue&gt; in the application.Me: Why?YD(Young dev): It will help us scale faster in the future and guard against the impedance mismatch between the core business logic and the rate at which clients hit the API.Me: Sure, but do you really want to take on the complexity of having a distributed queue so soon in the life cycle of your application? It'll probably not hit the scale you mentioned for quite some timeYD: Oh there's no complexity, we can just use the one provided by &lt;cloud-provider-x&gt;Me: But what if it looses data? Since your application deals with money, it is critical we don't loose a single piece of informationYD: How will a queue loose data?Me: Any distributed system can loose dataYD: How so?Me: Ever had a payment fail where your money was deducted but the order failed at the merchant page? That's a distributed system losing data (Not the best of examples, I know)YD: That's different. Those are multiple different services and ecosystems. Queues reside within the same private cloud - probably the same data center. The problems of the internet don't apply here (Oh Snap! He got me)Me: Yes, but there is still a network. And the queue given by &lt;cloud-provider-x&gt; is yet another piece of software written by people like you and me. What if it has a bug ?YD: OhI encouraged him to read Distributed Systems for Fun and profit.I also showed him how the complexity of his system lies in the design of the data model and the API and not in scale (yet).A good model would also help us ‘scale well’ in the future (when we may, inevitably, have to rely on complicated distributed systems)10There was yet another instance of a more seasoned developer who wanted to rewrite our order management system and use &lt;the-latest-and-greatest&gt; NoSQL solution offered by &lt;cloud-provider-x&gt;.It would help us ‘be ready’ for a potentially 100x more scale than what we’re currently facing, he claimed.This in itself was scary (refer previous discussion), but what was scarier was that not once did he mention Whether or if going with NoSQL was inherently better since it would provide us with a data model that will prevent future developers from shooting themselves in the foot If all the complex business use cases could be handled within the bounds (such as row level atomicity) imposed by the NoSQL data store (the current system relied heavily on RDBMs transactions to stay ‘correct’)My whole point is this - yes, what we do is generally complex and we live in a world where our tools are constantly evolving. We need to continuously up skill ourselves and learn more to stay relevant.It is important to have the knowledge of a number of tools in our mental tool set - so we can employ any of them for the job at hand.It is more important, however, to get an understanding of using the right tool for the job. Our work as engineers is to help the company make money by keeping customers happy. Not to show off the latest-thing-I-just-learnt-about to our peers.Your way is wrongAs already mentioned, there is no ‘absolute right’ when it comes to Engineering Stuff. Similarly, there is no ‘absolute wrong’.One of my favourite software stories is unfortunately not a first hand experience. This was from early 2010s when a friend worked for a company that deployed engineers in the client’s team to augment their bandwidth. They were supporting a complicated piece of legacy software. My friend found a piece of code ‘written in an odd way’. He couldn’t intuitively grasp it and thought it could be ‘written better’11. He did what most of us do - googled around and found a better way.He then cautiously approached the grey-bearded engineer who had originally written that code. My friend pointed to the ‘design pattern’ on the internet and suggested how code could be written better.To his absolute credit, my friend inquired sincerely as to why the code was written the way it was.To this, the older engineer promptly replied “Why yes, of course this does seem better. But you know the thing is, when I wrote this, there was no internet”I absolutely love this story and remind myself each time I look to blame someone for how it’s written.If you write code for long enough, you will come across code that would want you to become the proverbial psychopath and shoot the original author.However, it is important to be empathetic instead. It is necessary to have mutual respect towards your peers(if you don’t, you probably shouldn’t be there in the first place12)If possible, try to understand why things are done the way they were done.If that’s not possible, it is perfectly fine to poke fun at the original author, make a note of how you’d change it instead and come back to it when you have the time. Move on13. Don’t spend time criticizing others.I hope you found this useful (assuming you didn’t come here just to see how it ends).I’d love to hear what you think. We don’t have a comment section yet, so if you want you can email me or comment on HackerNews Well, they still are - I’m just no longer part of the organisation &#8617;&#xfe0e; From ‘The Audacity of Hope’, Barack Obama &#8617;&#xfe0e; We all have &#8617;&#xfe0e; Well, I’ll be honest - wakatime says I clocked about 700 hours last year. But I’m sure you’re a better developer than I am :) &#8617;&#xfe0e; We’ve all done it, admit it &#8617;&#xfe0e; C++ is notoriously famous for giving you many ways to shoot yourself in the foot &#8617;&#xfe0e; A mixture of irate, sad, I-want-to-end-this-interview-right-now kinda feeling &#8617;&#xfe0e; In which case, what were you smoking when you chose that in the first place ? &#8617;&#xfe0e; Before the keen reader remarks ‘but were they any good?’. Yes they were - he made enough money that he was working ‘for fun’ now &#8617;&#xfe0e; To his credit, he did go through the entire book and did a remarkably good job at iterating over his API design and data model. &#8617;&#xfe0e; You can substitute ‘written better’ with your choice of lingo - ‘better designed’, ‘used better abstractions’ or what-have-you. &#8617;&#xfe0e; A good place to be is where the feeling of looser-ish-ness is prevalent. If you’re the smartest person in the room, you should look for better places &#8617;&#xfe0e; All of us have done this and others would do it for your code as well, because here’s the thing - there is no such thing as perfect code. &#8617;&#xfe0e; " } ]
